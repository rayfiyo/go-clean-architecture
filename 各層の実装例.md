# 各層の実装例

```
/app
├─ cmd/server/main.go
├─ internal/
│  ├─ domain/
│  │  ├─ command.go
│  │  ├─ result.go
│  │  └─ decoder.go
│  ├─ usecase/
│  │  ├─ ports.go
│  │  └─ decode_interactor.go
│  ├─ adapter/
│  │  ├─ http/
│  │  │  ├─ handler.go
│  │  │  └─ router.go
│  │  ├─ parse/
│  │  │  ├─ parser.go
│  │  │  └─ whitespace_parser.go
│  │  ├─ validate/
│  │  │  ├─ validator.go
│  │  │  └─ command_validator.go
│  │  └─ presenter/
│  │     └─ response.go
│  └─ platform/
│     ├─ di.go
│     └─ config.go
├─ go.mod
└─ build/Dockerfile
```

## ドメイン層(Domain)

- 目的: ルールそのものを表し、外界は知らない
- 定義したユビキタス言語を表現する

### 実装

- 概念「Command」を定義する
  - コマンドは「CommandType」と「Payload」を持つものとする
  - CommandType は「文字列 →ASCII（StoA）」または「ASCII→ 文字列（AtoS）」である
- 概念「Result」を定義する
  - 結果は 文字列 または 数値列 のどちらか一方を保持するものとする
- 概念「decoder」を定義する
  - decoder は「コマンドを受け取り、結果を返す」純粋な振る舞いを持つ
  - コマンドが StoA である場合:
    入力の各文字を取り出し、その ASCII 10 進を並べた数値列を作成して返す
  - コマンドが AtoS である場合:
    入力の数値列を 10 進数として解釈し、それぞれを文字にして連結したテキストを返す
  - 不正値が混じる場合は「不正である」ことを返す

## アプリケーション層(Application / Use Case)

- 目的: ドメインをどう使うかの手順を記述する（外界の形式は知らない）

### 実装（Decode ユースケース）

- 「デコード入力」を受け取る。入力は生の文字列である
- 次の順序で処理する：
  1. パースに委ね、生文字列からコマンドを得る
     - パースに失敗した場合、「構文不正」を返して処理を終える
  2. バリデーションに委ね、コマンドの整合性を確かめる。
     - 実装する規則:
       - 命令は 1 つであること
       - 文字は ASCII 範囲であること
       - 数値表記は 10 進・区切り規則に従うこと
     - 失敗した場合、「不正なコマンド」を返して処理を終える
  3. デコーダに委ね、コマンドを実行して結果を得る
     - デコーダが不正を検出した場合、「実行不可能」を返す
  4. 出力の組み立てを行い、結果をユースケース出力として整形する
     - ユースケースは上記の 4 段を順序通りに行い、成功または失敗のいずれかで終了する
     - ユースケースは HTTP や JSON を知らず、知っているのは次の抽象だけ
       - 入力は生文字列
       - 出力はテキスト/数値列のどちらか

## インターフェース／アダプタ層(Interface / Adapter)

- 目的: 外界の形式（HTTP, JSON, Whitespace 表記）とアプリケーションを相互に翻訳する

### 実装（HTTP ハンドラ）

- 依頼「POST /v1/decode」を受け付ける
- リクエストボディを取り出し、ユースケース の入力に詰め替える
- ユースケースを呼ぶ
- 返ってきたユースケース出力を プレゼンター で HTTP レスポンスに整形し、返す
- ユースケース起因のエラー: 業務エラーとして HTTP 4xx
- サーバ内部の失敗: 5xx

### 実装（パーサ）

- 生文字列を「Whitespace 構文の 1 命令」と仮定し、
  - それが StoA に該当すると判断できる場合:
    コマンド種別を StoA とし、ペイロードに元文字列を入れる
  - それが AtoS に該当すると判断できる場合:
    コマンド種別を AtoS とし、ペイロードに数値列（外形は文字列のままでよい）を入れる
  - どちらでもない場合:
    パース失敗を返す
- パーサはユースケースにのみ依存し、ドメイン型（コマンド）を返せること

### 実装（バリデータ）

- コマンドの規則を確かめる
  - StoA の場合: ペイロード内の各文字が ASCII 範囲内であること
  - AtoS の場合:
    ペイロードの数値列が規定の区切り（例：空白）で分かれており、
    各要素が整数で 0〜127 内であること
- 不正であれば、その理由を含んだ失敗を返す

### 実装（プレゼンター）

- ユースケース出力を、クライアント契約に沿う JSON へ組み替える
  - 結果がテキストである場合: `{"text": "..."}`
  - 結果が数値列である場合: `{"numbers": [65,66,67]}`
  - 失敗である場合: `{"error": {"code": "...", "message": "..."}}`
- HTTP ステータスとの対応もここで決める

## インフラ層(Infrastructure)

- 目的: 実行の場を用意する。ライフサイクル管理と依存の組み立てを行う

### 実装

- 依存解決（組み立て）を行う
  - ドメインのデコーダ実装を作る
  - パーサ実装とバリデータ実装を作る
  - 上記を引数にユースケース（インタラクタ）を作る
  - ユースケースを引数に HTTP ハンドラを作る
  - ハンドラをルータに登録する
- サーバ起動 を行う
  - ポート 3000 でリッスンし、`/v1/decode`を公開する
- Docker 実行を行う
  - 実行ファイル`/app/main`をエントリポイントとする
- デプロイを行う
  - コンテナイメージを ECR へ登録する
  - ECS サービスに対し新しいイメージのデプロイを要求する（強制ローリング）
- ログ／設定／メトリクスはここに置く。ビジネスルールへは侵入しない
